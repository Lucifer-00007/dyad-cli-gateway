/**
 * Vulnerability Scanner Service
 * Automated security scanning for dependencies and containers
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const cron = require('node-cron');
const logger = require('../../config/logger');
const securityConfig = require('../config/security.config');

class VulnerabilityScanner {
  constructor() {
    this.scanResults = new Map();
    this.lastScanTime = null;
    this.isScanning = false;
    
    // Schedule automatic scans if enabled
    if (securityConfig.vulnerabilityScanning.enabled) {
      this.scheduleScans();
    }
  }

  /**
   * Schedule automatic vulnerability scans
   */
  scheduleScans() {
    const schedule = securityConfig.vulnerabilityScanning.schedule;
    
    cron.schedule(schedule, async () => {
      logger.info('Starting scheduled vulnerability scan');
      try {
        await this.runFullScan();
      } catch (error) {
        logger.error('Scheduled vulnerability scan failed', { error: error.message });
      }
    });

    logger.info('Vulnerability scanning scheduled', { schedule });
  }

  /**
   * Run a full security scan
   */
  async runFullScan() {
    if (this.isScanning) {
      logger.warn('Vulnerability scan already in progress');
      return this.scanResults;
    }

    this.isScanning = true;
    const scanId = `scan_${Date.now()}`;
    
    try {
      logger.info('Starting full vulnerability scan', { scanId });
      
      const results = {
        scanId,
        timestamp: new Date().toISOString(),
        scans: {}
      };

      // Run dependency scan
      try {
        results.scans.dependencies = await this.scanDependencies();
      } catch (error) {
        logger.error('Dependency scan failed', { error: error.message });
        results.scans.dependencies = { error: error.message };
      }

      // Run container scan if enabled
      if (securityConfig.container.scanEnabled) {
        try {
          results.scans.container = await this.scanContainer();
        } catch (error) {
          logger.error('Container scan failed', { error: error.message });
          results.scans.container = { error: error.message };
        }
      }

      // Run configuration scan
      try {
        results.scans.configuration = await this.scanConfiguration();
      } catch (error) {
        logger.error('Configuration scan failed', { error: error.message });
        results.scans.configuration = { error: error.message };
      }

      // Analyze results
      results.summary = this.analyzeScanResults(results.scans);
      
      // Store results
      this.scanResults.set(scanId, results);
      this.lastScanTime = new Date();

      // Alert on critical findings
      if (results.summary.criticalCount > 0) {
        await this.sendSecurityAlert(results);
      }

      logger.info('Vulnerability scan completed', {
        scanId,
        summary: results.summary
      });

      return results;
    } finally {
      this.isScanning = false;
    }
  }

  /**
   * Scan Node.js dependencies for vulnerabilities
   */
  async scanDependencies() {
    logger.info('Scanning dependencies for vulnerabilities');
    
    try {
      // Use npm audit for dependency scanning
      const auditOutput = execSync('npm audit --json', {
        cwd: process.cwd(),
        encoding: 'utf8',
        timeout: 60000
      });

      const auditData = JSON.parse(auditOutput);
      
      const vulnerabilities = [];
      const severityThreshold = securityConfig.vulnerabilityScanning.severityThreshold;
      
      // Process audit results
      if (auditData.vulnerabilities) {
        for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
          if (this.shouldReportVulnerability(vulnData.severity, severityThreshold)) {
            vulnerabilities.push({
              package: packageName,
              severity: vulnData.severity,
              title: vulnData.title,
              url: vulnData.url,
              range: vulnData.range,
              fixAvailable: vulnData.fixAvailable
            });
          }
        }
      }

      return {
        status: 'completed',
        timestamp: new Date().toISOString(),
        totalVulnerabilities: vulnerabilities.length,
        vulnerabilities,
        metadata: {
          totalDependencies: auditData.metadata?.totalDependencies || 0,
          vulnerabilities: auditData.metadata?.vulnerabilities || {}
        }
      };
    } catch (error) {
      // Handle case where npm audit returns non-zero exit code (vulnerabilities found)
      if (error.stdout) {
        try {
          const auditData = JSON.parse(error.stdout);
          return this.processDependencyScanResults(auditData);
        } catch (parseError) {
          throw new Error(`Failed to parse npm audit output: ${parseError.message}`);
        }
      }
      throw error;
    }
  }

  /**
   * Scan container images for vulnerabilities
   */
  async scanContainer() {
    logger.info('Scanning container images for vulnerabilities');
    
    const results = {
      status: 'completed',
      timestamp: new Date().toISOString(),
      images: []
    };

    // List of images to scan
    const imagesToScan = [
      'node:18-alpine',
      process.env.GATEWAY_SANDBOX_IMAGE || 'node:18-alpine'
    ];

    for (const image of imagesToScan) {
      try {
        const imageResult = await this.scanSingleImage(image);
        results.images.push(imageResult);
      } catch (error) {
        logger.error('Failed to scan container image', { image, error: error.message });
        results.images.push({
          image,
          status: 'failed',
          error: error.message
        });
      }
    }

    return results;
  }

  /**
   * Scan a single container image
   */
  async scanSingleImage(image) {
    // This is a simplified implementation
    // In production, you would use tools like Trivy, Clair, or Snyk
    
    try {
      // Check if image exists locally
      execSync(`docker image inspect ${image}`, { stdio: 'ignore' });
      
      return {
        image,
        status: 'scanned',
        vulnerabilities: [],
        note: 'Container scanning requires external tools like Trivy or Snyk'
      };
    } catch (error) {
      return {
        image,
        status: 'not_found',
        error: 'Image not found locally'
      };
    }
  }

  /**
   * Scan application configuration for security issues
   */
  async scanConfiguration() {
    logger.info('Scanning configuration for security issues');
    
    const issues = [];
    
    // Check environment variables
    const envIssues = this.checkEnvironmentSecurity();
    issues.push(...envIssues);
    
    // Check file permissions
    const fileIssues = await this.checkFilePermissions();
    issues.push(...fileIssues);
    
    // Check security headers configuration
    const headerIssues = this.checkSecurityHeaders();
    issues.push(...headerIssues);
    
    return {
      status: 'completed',
      timestamp: new Date().toISOString(),
      totalIssues: issues.length,
      issues
    };
  }

  /**
   * Check environment variables for security issues
   */
  checkEnvironmentSecurity() {
    const issues = [];
    
    // Check for insecure defaults
    if (process.env.NODE_ENV !== 'production') {
      issues.push({
        type: 'configuration',
        severity: 'medium',
        title: 'Non-production environment detected',
        description: 'NODE_ENV is not set to production',
        recommendation: 'Set NODE_ENV=production for production deployments'
      });
    }
    
    // Check HTTPS enforcement
    if (!securityConfig.https.required) {
      issues.push({
        type: 'configuration',
        severity: 'high',
        title: 'HTTPS not enforced',
        description: 'HTTPS enforcement is disabled',
        recommendation: 'Enable HTTPS enforcement in production'
      });
    }
    
    // Check for debug mode
    if (process.env.DEBUG) {
      issues.push({
        type: 'configuration',
        severity: 'medium',
        title: 'Debug mode enabled',
        description: 'Debug logging is enabled',
        recommendation: 'Disable debug mode in production'
      });
    }
    
    return issues;
  }

  /**
   * Check file permissions for security issues
   */
  async checkFilePermissions() {
    const issues = [];
    
    try {
      // Check package.json permissions
      const packageJsonPath = path.join(process.cwd(), 'package.json');
      const stats = await fs.stat(packageJsonPath);
      
      // Check if file is world-writable (security risk)
      if (stats.mode & 0o002) {
        issues.push({
          type: 'permissions',
          severity: 'medium',
          title: 'World-writable package.json',
          description: 'package.json is writable by all users',
          recommendation: 'Restrict package.json permissions'
        });
      }
    } catch (error) {
      // File doesn't exist or can't be accessed
    }
    
    return issues;
  }

  /**
   * Check security headers configuration
   */
  checkSecurityHeaders() {
    const issues = [];
    
    if (!securityConfig.headers.enabled) {
      issues.push({
        type: 'headers',
        severity: 'high',
        title: 'Security headers disabled',
        description: 'Security headers are not enabled',
        recommendation: 'Enable security headers for better protection'
      });
    }
    
    if (!securityConfig.csp.enabled) {
      issues.push({
        type: 'headers',
        severity: 'medium',
        title: 'Content Security Policy disabled',
        description: 'CSP headers are not enabled',
        recommendation: 'Enable CSP headers to prevent XSS attacks'
      });
    }
    
    return issues;
  }

  /**
   * Analyze scan results and generate summary
   */
  analyzeScanResults(scans) {
    const summary = {
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
      totalIssues: 0,
      recommendations: []
    };

    // Count vulnerabilities by severity
    for (const [scanType, scanResult] of Object.entries(scans)) {
      if (scanResult.vulnerabilities) {
        scanResult.vulnerabilities.forEach(vuln => {
          summary.totalIssues++;
          switch (vuln.severity) {
            case 'critical':
              summary.criticalCount++;
              break;
            case 'high':
              summary.highCount++;
              break;
            case 'medium':
              summary.mediumCount++;
              break;
            case 'low':
              summary.lowCount++;
              break;
          }
        });
      }
      
      if (scanResult.issues) {
        scanResult.issues.forEach(issue => {
          summary.totalIssues++;
          switch (issue.severity) {
            case 'critical':
              summary.criticalCount++;
              break;
            case 'high':
              summary.highCount++;
              break;
            case 'medium':
              summary.mediumCount++;
              break;
            case 'low':
              summary.lowCount++;
              break;
          }
          
          if (issue.recommendation) {
            summary.recommendations.push(issue.recommendation);
          }
        });
      }
    }

    return summary;
  }

  /**
   * Send security alert for critical findings
   */
  async sendSecurityAlert(scanResults) {
    const alertData = {
      type: 'security_vulnerability',
      severity: 'critical',
      timestamp: new Date().toISOString(),
      scanId: scanResults.scanId,
      summary: scanResults.summary,
      criticalVulnerabilities: this.extractCriticalVulnerabilities(scanResults.scans)
    };

    logger.error('Critical security vulnerabilities detected', alertData);

    // Send webhook alert if configured
    if (securityConfig.monitoring.alertWebhook) {
      try {
        const axios = require('axios');
        await axios.post(securityConfig.monitoring.alertWebhook, alertData, {
          timeout: 10000,
          headers: { 'Content-Type': 'application/json' }
        });
        logger.info('Security alert webhook sent successfully');
      } catch (error) {
        logger.error('Failed to send security alert webhook', { error: error.message });
      }
    }
  }

  /**
   * Extract critical vulnerabilities from scan results
   */
  extractCriticalVulnerabilities(scans) {
    const critical = [];
    
    for (const [scanType, scanResult] of Object.entries(scans)) {
      if (scanResult.vulnerabilities) {
        const criticalVulns = scanResult.vulnerabilities.filter(v => v.severity === 'critical');
        critical.push(...criticalVulns.map(v => ({ ...v, scanType })));
      }
      
      if (scanResult.issues) {
        const criticalIssues = scanResult.issues.filter(i => i.severity === 'critical');
        critical.push(...criticalIssues.map(i => ({ ...i, scanType })));
      }
    }
    
    return critical;
  }

  /**
   * Check if vulnerability should be reported based on severity threshold
   */
  shouldReportVulnerability(severity, threshold) {
    const severityLevels = { low: 1, medium: 2, high: 3, critical: 4 };
    return severityLevels[severity] >= severityLevels[threshold];
  }

  /**
   * Get latest scan results
   */
  getLatestScanResults() {
    if (this.scanResults.size === 0) {
      return null;
    }
    
    const latestScanId = Array.from(this.scanResults.keys()).sort().pop();
    return this.scanResults.get(latestScanId);
  }

  /**
   * Get scan status
   */
  getScanStatus() {
    return {
      isScanning: this.isScanning,
      lastScanTime: this.lastScanTime,
      totalScans: this.scanResults.size,
      latestResults: this.getLatestScanResults()?.summary || null
    };
  }
}

// Export singleton instance
module.exports = new VulnerabilityScanner();